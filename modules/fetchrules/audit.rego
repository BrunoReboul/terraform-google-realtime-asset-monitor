#
# Copyright 2024 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

package validator.gcp.lib

# RULE: the audit rule is result if its body {} evaluates to true
# The rule body {} can be understood intuitively as: expression-1 AND expression-2 AND ... AND expression-N
audit[result] {
	# iterate over each asset
	asset := input.assets[_]
	# WARNING - FOR LOCAL TESTING use asset := data.assets[_]

	trace(sprintf("asset name: %v", [asset.name]))

	# assign the constrains in a variable
	constraints := input.constraints
	# WARNING - FOR LOCAL TESTING use constraints := data.constraints
	
	# iterate over each constraint
	constraint := constraints[_]
	trace(sprintf("constraint kind: %v", [constraint.kind]))    

	# use a custom function to retrieve constraint.spec, if not defined returns a default value that is an empty object
	spec := _get_default(constraint, "spec", {})
	# use a custom function to retrieve constraint.spec.match, if not defined returns a default value that is an empty object
	match := _get_default(spec, "match", {})
	# use a custom function to retrieve constraint.spec.match.target, if not defined returns a default value that is an array with one target object targeting any organization, and child
	target := _get_default(match, "target", ["organization/*"])
	# use a custom function to retrieve constraint.spec.match.gcp, if not defined returns a default value that is an empty object
	gcp := _get_default(match, "gcp", {})
	# use a custom function to retrieve constraint.spec.match.gcp.target, if not defined returns what we already got in target variable
	gcp_target := _get_default(gcp, "target", target)
	# iterate over each target and use builtin regex to check if the asset ancestry path matches one of them
	# TRUE if the asset ancestry path matches (regex) one of the target (iterate targets)
	# FALSE when the ancestry path do not matches at least one of the target
	trace(sprintf("asset.ancestry_path: %v", [asset.ancestry_path]))
	trace(sprintf("targets: %v", [gcp_target]))
	trace(sprintf("is in scope:",[regex.match(gcp_target[_], asset.ancestry_path)]))
	regex.match(gcp_target[_], asset.ancestry_path)

	# use a custom function to retrieve constraint.spec.match.exclude, if not defined returns a default value that is an empty array
	exclude := _get_default(match, "exclude", [])
	# use a custom function to retrieve constraint.spec.match.gcp.exclude, if not defined returns what we already got in exclude variable
	gcp_exclude := _get_default(gcp, "exclude", exclude)
	# iterate over the exclusion list (the pattern) and use regex builtin function to check if the asset ancestry path (the value) matches one of then
	# assign to exclusion_match variable the virtual document generated by a rule which is a set built by using a comprehension
	# This set contains the asset ancestry path if it matches one of the exclusion
	# or is empty (set()) if the asset ancestry path does not matched any of the exclusion
	exclusion_match := {asset.ancestry_path | regex.match(gcp_exclude[_], asset.ancestry_path)}
	trace(sprintf("exclusions: %v", [gcp_exclude]))
	trace(sprintf("Excluded if count exclusion_match > 0: %v", [count(exclusion_match)]))
	# this expression evaluate to true when count is zero, aka the ancestry path does not matches any of the exclusion, otherwise evaluates to false
	count(exclusion_match) == 0

	# Use a with statement to programmatically call the rego rule that is specified in the YAML constraint file
	violations := data.templates.gcp[constraint.kind].deny with input.asset as asset
		 with input.constraint as constraint

	# Iterates through each violation found
	violation := violations[_]
	# if the asset is in target, and not excluded and at least one violation is founds, then returns for each violation a result object with the 4 following fields:
	result := {
		"asset": asset.name,
		"constraint": constraint.metadata.name,
		"constraint_config": constraint,
		"violation": violation,
	}
}

# has_field returns whether an object has a field
_has_field(object, field) {
	object[field]
}

# False is a tricky special case, as false responses would create an undefined document unless
# they are explicitly tested for
_has_field(object, field) {
	object[field] == false
}

_has_field(object, field) = false {
	not object[field]
	not object[field] == false
}

# get_default returns the value of an object's field or the provided default value.
# It avoids creating an undefined state when trying to access an object attribute that does
# not exist
_get_default(object, field, _default) = output {
	_has_field(object, field)
	output = object[field]
}

_get_default(object, field, _default) = output {
	_has_field(object, field) == false
	output = _default
}
